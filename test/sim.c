
#include <math.h>

#include "../src/io-sim.h"

#undef N_ELEMENTS
#define N_ELEMENTS(array) (sizeof(array) / sizeof(*array))

static vbi_sampling_par _sp;
static vbi_raw_decoder *_rd;
static double sim_time;

static int caption_i = 0;
static const uint8_t caption_text[] = {
	0x14, 0x25, 0x14, 0x25, 'L', 'I', 'B', 'Z',
	'V', 'B', 'I', ' ', 'C', 'A', 'P', 'T',
	'I', 'O', 'N', ' ', 'S', 'I', 'M', 'U',
	'L', 'A', 'T', 'I', 'O', 'N', 0x14, 0x2D,
	0x14, 0x2D /* even size please, add 0 if neccessary */
};

static uint8_t *
ttx_next(void)
{
	static uint8_t s1[2][10] = {
		{ 0x02, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15 },
		{ 0x02, 0x15, 0x02, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15 }
	};
	static uint8_t s2[32] = "100\2LIBZVBI\7            00:00:00";
	static uint8_t s3[40] = "  LIBZVBI TELETEXT SIMULATION           ";
	static uint8_t s4[40] = "  Page 100                              ";
	static uint8_t s5[10][42] = {
		{ 0x02, 0x2f, 0x97, 0x20, 0x37, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0xb5, 0x20 },
		{ 0xc7, 0x2f, 0x97, 0x0d, 0xb5, 0x04, 0x20, 0x9d, 0x83, 0x8c,
		  0x08, 0x2a, 0x2a, 0x2a, 0x89, 0x20, 0x20, 0x0d, 0x54, 0x45,
		  0xd3, 0x54, 0x20, 0xd0, 0xc1, 0xc7, 0x45, 0x8c, 0x20, 0x20,
		  0x08, 0x2a, 0x2a, 0x2a, 0x89, 0x0d, 0x20, 0x20, 0x1c, 0x97,
		  0xb5, 0x20 },
		{ 0x02, 0xd0, 0x97, 0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0xea, 0x20 },
		{ 0xc7, 0xd0, 0x97, 0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0xb5, 0x20 },
		{ 0x02, 0xc7, 0x97, 0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x15, 0x1a, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
		  0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2c,
		  0x2c, 0x2c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x97, 0x19,
		  0xb5, 0x20 },
		{ 0xc7, 0xc7, 0x97, 0x20, 0xb5, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		  0xb5, 0x20 },
		{ 0x02, 0x8c, 0x97, 0x9e, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x13,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x16, 0x7f, 0x7f, 0x7f, 0x7f, 0x92,
		  0x7f, 0x92, 0x7f, 0x7f, 0x15, 0x7f, 0x7f, 0x15, 0x7f, 0x91,
		  0x91, 0x7f, 0x7f, 0x91, 0x94, 0x7f, 0x94, 0x7f, 0x94, 0x97,
		  0xb5, 0x20 },
		{ 0xc7, 0x8c, 0x97, 0x9e, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x13,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x16, 0x7f, 0x7f, 0x7f, 0x7f, 0x92,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x15, 0x7f, 0x7f, 0x7f, 0x7f, 0x91,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x94, 0x7f, 0x7f, 0x7f, 0x7f, 0x97,
		  0xb5, 0x20 },
		{ 0x02, 0x9b, 0x97, 0x9e, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x13,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x16, 0x7f, 0x7f, 0x7f, 0x7f, 0x92,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x15, 0x7f, 0x7f, 0x7f, 0x7f, 0x91,
		  0x7f, 0x7f, 0x7f, 0x7f, 0x94, 0x7f, 0x7f, 0x7f, 0x7f, 0x97,
		  0xb5, 0x20 },
		{ 0xc7, 0x9b, 0x97, 0x20, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
		  0xa1, 0x20 }
	};
	static uint8_t buf[45];
	static int row = 0, page = 0;
	int i;

	buf[0] = 0x55;
	buf[1] = 0x55;
	buf[2] = 0x27;

	if (row == 0) {
		memcpy(buf + 3, s1[page], 10);
		page ^= 1;
		for (i = 0; i < 32; i++)
			buf[13 + i] = vbi_fpar8(s2[i]);
	} else if (row == 1) {
		buf[3] = 0x02; buf[4] = 0x02;
		for (i = 0; i < 40; i++)
			buf[5 + i] = vbi_fpar8(s3[i]);
	} else if (row == 2) {
		buf[3] = 0x02; buf[4] = 0x49;
		for (i = 0; i < 40; i++)
			buf[5 + i] = vbi_fpar8(s4[i]);
	} else {
		memcpy(buf + 3, s5[row - 3], 42);
	}

	if (++row >= 13) row = 0;

	return buf;
}

static void
read_sim(uint8_t *raw_data, vbi_sliced *sliced_data,
	 int *lines, double *timestamp)
{
	vbi_sliced sliced[50];
	int j;

	memset (raw_data, 0,
		(_sp.count[0] + _sp.count[1])
		* _sp.bytes_per_line);

	*timestamp = sim_time;

	if (VBI_VIDEOSTD_SET_525_60 & _sp.videostd_set)
		sim_time += 1001 / 30000.0;
	else
		sim_time += 1 / 25.0;

	j = 0;

	if (VBI_VIDEOSTD_SET_525_60 & _sp.videostd_set) {
		/* Closed Caption */

		sliced[j].id = VBI_SLICED_CAPTION_525;
		sliced[j].line = 21;
		sliced[j].data[0] = vbi_fpar8 (caption_text[caption_i]);
		sliced[j].data[1] = vbi_fpar8 (caption_text[caption_i + 1]);

		if ((caption_i += 2) > sizeof(caption_text))
			caption_i = 0;
		++j;

		/* Teletext */
		{
			unsigned int i;

			for (i = 0; i < N_ELEMENTS (sliced[j].data); ++i)
				sliced[j].data[i] = rand ();

			memcpy (&sliced[j + 1], &sliced[j], sizeof (sliced[j]));
			memcpy (&sliced[j + 2], &sliced[j], sizeof (sliced[j]));

			sliced[j + 0].id = VBI_SLICED_TELETEXT_B_525;
			sliced[j + 0].line = 10;
			sliced[j + 1].id = VBI_SLICED_TELETEXT_C_525;
			sliced[j + 1].line = 11;
			sliced[j + 2].id = VBI_SLICED_TELETEXT_D_525;
			sliced[j + 2].line = 12;

			j += 3;
		}
	} else {
		/* Closed Caption */

		sliced[j].id = VBI_SLICED_CAPTION_625;
		sliced[j].line = 22;
		sliced[j].data[0] = vbi_fpar8 (caption_text[caption_i]);
		sliced[j].data[1] = vbi_fpar8 (caption_text[caption_i + 1]);

		if ((caption_i += 2) > sizeof(caption_text))
			caption_i = 0;
		++j;

		/* WSS PAL */
		{
			int g0 = 1, g1 = 2, g2 = 3, g3 = 4;
			int bits = (g3 << 11) + (g2 << 8) + (g1 << 4) + g0;

			sliced[j].id = VBI_SLICED_WSS_625;
			sliced[j].line = 23;
			sliced[j].data[0] = bits;
			sliced[j].data[1] = bits >> 8;

			++j;
		}

		/* Teletext */
		{
			unsigned int i;

			for (i = 0; i < N_ELEMENTS (sliced[j].data); ++i)
				sliced[j].data[i] = rand ();

			memcpy (&sliced[j + 1], &sliced[j], sizeof (sliced[j]));
			memcpy (&sliced[j + 2], &sliced[j], sizeof (sliced[j]));

			sliced[j + 0].id = VBI_SLICED_TELETEXT_A;
			sliced[j + 0].line = 6;
			sliced[j + 1].id = VBI_SLICED_TELETEXT_C_625;
			sliced[j + 1].line = 7;
			sliced[j + 2].id = VBI_SLICED_TELETEXT_D_625;
			sliced[j + 2].line = 8;

			j += 3;
		}

		/* Teletext */
		{
			static const uint16_t lines [] = {
				9, 10, 11, 12, 13, 14, 15,
				19, 20, 21,
				320, 321, 322, 323, 324, 325, 326, 327, 328,
				332, 333, 334, 335
			};
			unsigned int i;

			for (i = 0; i < N_ELEMENTS (lines); ++i) {
				uint8_t *text;

				sliced[j].id = VBI_SLICED_TELETEXT_B;
				sliced[j].line = lines[i];

				text = ttx_next();
				memcpy (&sliced[j].data, text + 3, 42);

				++j;
			}
		}
	}

	_vbi_test_image_vbi (raw_data, 0, &_sp, sliced, j);

	*lines = vbi_raw_decoder_decode (_rd, sliced_data,
					 /* FIXME */ 50, raw_data);
}

static vbi_raw_decoder *
init_sim(int scanning, unsigned int services)
{
	vbi_videostd_set vs;

	sim_time = 0.0;

        switch (scanning) {
        case 525:
		vs = VBI_VIDEOSTD_SET_525_60;
                break;
        case 625:
                vs = VBI_VIDEOSTD_SET_625_50;
                break;
        default:
		assert (0);
        }

	services = vbi_sampling_par_from_services (&_sp, NULL, vs, services);
	assert (0 != services);

	_rd = vbi_raw_decoder_new (&_sp);
	assert (NULL != _rd);

	vbi_raw_decoder_add_services (_rd, services, 0);

	return _rd;
}
