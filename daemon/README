About Linux "VBI proxy"
-----------------------

The "video4linux" drivers allow capturing only to one VBI client at
the same time.  This means, if you have a background application like
the nxtvepg daemon running, you won't be able to start a teletext
application.  [Note that although the v4l2 API allows multiple clients
to open the device, still only one client may capture the same frame's
data]

The VBI proxy is developed as a solution to this problem.  Afterall
there's no good reason that only one app should be able to capture VBI,
since there are many independent data streams, e.g. VPS/PDC (channel
identification and programme labels for video recoding), WSS (widescreen
and surround sound signalling), teletext, and inside teletext besides
the regular pages also subtitles, Nextview Electronic Programme Guide,
Teleweb (enhanced teletext based on HTML) and possibly more binary coded
data streams.

In particular there are some TV apps which always open the VBI device
(for subtitles, WSS or whatever) so it's currently impossible to capture
any of the above data services in the background.

As a second, optional feature, the proxy may in the future be used to
coordinate channel changes between multiple VBI background applications
or between video and VBI apps;  the latter is mainly interesting for
v4l2 drivers, where it's no longer possible to determine if a TV app
is running before switching the channel in a background app (these apps
relied on the fact that v4l1 devices can be opened only once.)  Hence
VBI apps currently may annoy v4l2 users by switching the channel while
you're watching TV.

One drawback of the proxy is that it requires to adapt all cooperating
VBI clients.  For most applications which already use libzvbi the required
work is however expected to be minimal: just one additional function call
before calling the regular device open functions.  Again other applications
(e.g. alevt) which are still based on v4l1 can be easily changed to use
libzvbi.  Hopefully the solution will be simple and elegant enough to
convince the authors to invest the necessary effort to switch to libzvbi
(or at least implement the protocol) in subsequent releases of their
software.


2003-04-27
----------

I've got a working prototype for the VBI proxy based on libzvbi. Both
nxtvepg and alevt are already adapted for it.  Now you can run nxtvepg
and alevt in parallel, or multiple instances of alevt etc.  The client
interface to the proxy will probably not change (except for a few
additional functions to control channel changes) so authors could
already start to adapt their apps if interested.  Note the proxy daemon
is not complete yet, esp. dynamically merging different service requests
(i.e. services which read different VBI regions) might not work, it's
also not optimized at all yet.

I've made a demo proxy client "proxy-test" which serves as an example
how to work with libzvbi.  The daemon is called "proxyd".  Both apps
print usage info with -help. You can also look at my patch for alevt or
nxtvepg/epgvbi/btdrv4linux.c inside switch USE_LIBZVBI.  The effort for
the adaption should be only a few hours.

If you're using a v4l2 driver you should upgrade to the latest version
from http://bytesex.org/snapshot/ and apply my patches from the above
tmp directory.

If you've got any questions, feel free to ask.

2003-05-10
----------

This is an unordered list of open points (i.e. unimplemented or yet
undecided) regarding the proxy.  Any comments or help appreciated.
The list will be updated in CVS along with the implementation.

- libzvbi.h: should contain HAVE_PROXY macro or other means to query
  if proxy interface is available at compile time; may be mapped to
  a version number check.
- handling of buffer count in proxy (use max. count of all clients),
  dynamically changing buffer count in io modules.
- add raw buffer forward, possibly based on shared memory to avoid copying
  (mmapped DMA buffers can probably not directly be shared though, so
  one copy will be required in conjunction with streams buffers; copying
  may also be required if the client uses the read() interface; shm should
  still be more efficient than stuffing everything through a socket)
- startup "rc" script for proxy daemon; add daemon and rc for installation;
  daemon should be renamed to vbiproxyd for installation
- daemon man page
- add "-kill" option to daemon: kill already running daemon
- device permissions are implemented by copying group id and access
  mask of the device.  This is not portable however according to man
  socket(7).  Possibly a sub-directory should be used and permissions
  set on the directory. Disadvantage: other people cannot clean up (same
  for socket file if sticky bit is set). Or an X11 way a key file could 
  be used.
- test proxy_read() with zero timeout (in case client uses select to poll
  for incoming data)
- save errno upon device errors deep down, e.g. in proxy-msg.c into io struct
  to make sure it's not overwritten higher up in the return path
- automatically reconnect to daemon after error? (optional)
- currently vbi_capture_fd() returns -1 for proxy clients; instead the new
  get_poll_fd() func has to be used: this raises a backwards compatibility
  problem for clients which only use it for select anyways.  Could be avoided
  if it would be changed to only one get_fd() func and a 2nd one which
  returns if the fd (i) supports v4l ioctls and (ii) select/poll(2)

- channel change notifications: daemon must distribute event notifications
  to all connected clients; also v4l2k can detect channel changes with the
  VIDIOC_G_CHNEVENT extension -> not only proxy clients can make use of this
  feature. Still open how to deliver the notifications. Either a special
  return code or errno could be used, or an event hander function.  In both
  cases the user would have to call a config function first to enable these
  notifications.
- schedule channel change requests at background prio (evel 0) at multiple
  sub-prio levels, e.g. immanent VPS/PDC, initial load, update, check;
  (see also discussion on mailing list)
- implement client-side channel change handling for background level,
  i.e. request scheduling from daemon, but don't do the change until the
  scheduler sends a grant.
- channel change: skip 1-2 frames; still undecided if this should be done
  in the io-x modules or by the user or daemon.
- inform clients about video norm changes: e.g. sampling rate may change
  (only relevant for raw data though), frame rate changes -> must be
  considered when evaluating time stamps to detect dropped frames;
  number of VBI lines may change, client may want to change service IDs.
  Probably only for clients which explicitly enable this; others could
  simply be starved.
- DVB channel changes (http://www.linuxtv.org/developer/dvb_api.xml)
- channel_switch in io-v4l2.c module is still missing (relevant API parts
  differ from v4l2k); also test io-v4l2.c::add_services against bttv8
- io-bktr.c not supported at all yet for new features

- possibly add a generic capture client config function to:
  + pass proxy background scheduler settings: prio, sub-prio etc.
  + report channel events: TV channel/freq. change, norm change
  + enable auto-reconnect to proxy daemon
  + set video device path (v4l1 for channel changes & norm query)
  + sequence counter instead of time stamp in vbi_capture_buffer (v4l1 bttv)
- v4l2 API extensions:
  + channel change prio (implemented with #ifdef USE_V4L2K_CHNPRIO)
  + channel change event notification
  + CGUNIT to check if two nodes refer to the same piece of hardware?
    possibly extend struct v4l2_capability?
  + STREAMOFF to stop cature when using read()?  Else the device has to be
    closed and re-opend to allow S_FMT, e.g. during add_services

-tom
