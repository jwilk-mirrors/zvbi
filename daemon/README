About Linux "VBI proxy"
-----------------------

The "video4linux" drivers allow capturing only to one VBI client at
the same time.  This means, if you have a background application like
the nxtvepg daemon running, you won't be able to start a teletext
application.  [Note that although the v4l2 API allows multiple clients
to open the device, still only one client may capture the same frame's
data]

The VBI proxy is developed as a solution to this problem.  Afterall
there's no good reason that only one app should be able to capture VBI,
since there are many independent data streams, e.g. VPS/PDC (channel
identification and programme labels for video recoding), WSS (widescreen
and surround sound signalling), teletext, and inside teletext besides
the regular pages also subtitles, Nextview Electronic Programme Guide,
Teleweb (enhanced teletext based on HTML) and possibly more binary coded
data streams.

In particular there are some TV apps which always open the VBI device
(for subtitles, WSS or whatever) so it's currently impossible to capture
any of the above data services in the background.

As a second feature, the proxy can also coordinate channel changes
between background VBI "data harvesting" applications. Such apps would
register a channel request with the proxy together with a priority and
expected time of use and the proxy will then grant those requests
according to priority and previous grants in a round-robin way. It will
also attempt to detect if interactive applications are active and refrain
from channel changes during that time.

One drawback of the proxy is that it requires to adapt all cooperating
VBI clients.  Although in theory it would have been possible to write
a VBI loopback driver which simulates a regular v4l device but routes
all I/O back to the proxy in userspace. But this would have had the
drawback that only raw data could have been distributed and would have
been to be sliced by every application, which is a considerable waste
of CPU time.  Hence it was decided not to use that approach and instead
position the proxy at slicer level.

For most applications which already use libzvbi the required
work is however expected to be minimal: just one additional function call
before calling the regular device open functions.  Other applications
(e.g. alevt) which are still based on v4l1 can often easily be changed to
use libzvbi simply by exchanging open/read system calls with the respective
libzvbi calls and skipping the app's own slicing.

Hopefully the solution is elegant enough to convince the authors to
invest the necessary effort to switch to libzvbi (or at least implement
the protocol) in subsequent releases of their software.


Current status
--------------

The proxy is still in development, but the basic service is operational.
See below for a detailed list of open points.  If you want to try it out,
check out libzvbi from CVS at http://zapping.sourceforge.net/.  In the
test sub-directory there's a small programme called "proxy-text.c" which
allows to dump teletext or VPS via the proxy.  Various parameters can be
configured by command line options, use -help for a list.

For further demos you get from http://nxtvepg.sourceforge.net/tmp a
nxtvepg pre-release (enable -DUSE_LIBZVBI in the Makefile) or modify
alevt-1.6.1 with a patch from the same directory, or use xawdecode from
http://xawdecode.sourceforge.net/download/

Then you can run nxtvepg and alevt in parallel, or multiple instances of
alevt etc.  The client interface to the proxy will probably not change
(except for a few additional functions to control channel changes) so
authors could already start to adapt their apps if interested.

If you've got any questions, feel free to ask.



TODO list
---------

This is an unordered list of open points (i.e. unimplemented or yet
undecided) regarding the proxy.  Any comments or help appreciated.
The list will be updated in CVS along with the implementation.

- libzvbi.h: should contain HAVE_PROXY macro or other means to query
  if proxy interface is available at compile time; may be mapped to
  a version number check.
- handling of buffer count in proxy (use max. count of all clients),
  dynamically changing buffer count in io modules.
- add raw buffer forward, possibly based on shared memory to avoid copying
  (mmapped DMA buffers can probably not directly be shared though, so
  one copy will be required in conjunction with streams buffers; copying
  may also be required if the client uses the read() interface; shm should
  still be more efficient than stuffing everything through a socket)
- startup "rc" script for proxy daemon; add daemon and rc for installation;
  daemon should be renamed to vbiproxyd for installation
- daemon man page
- device permissions are implemented by copying group id and access
  mask of the device.  This is not portable however according to man
  socket(7).  Possibly a sub-directory should be used and permissions
  set on the directory. Disadvantage: other people cannot clean up (same
  for socket file if sticky bit is set). Or an X11 way a key file could 
  be used.
- save errno upon device errors deep down, e.g. in proxy-msg.c into io struct
  to make sure it's not overwritten higher up in the return path
- optionally suspend capturing while wrong channel is tuned?

- channel change notifications: daemon must distribute event notifications
  to all connected clients; also v4l2k can detect channel changes with the
  VIDIOC_G_CHNEVENT extension -> not only proxy clients can make use of this
  feature. Still open how to deliver the notifications. Either a special
  return code or errno could be used, or an event hander function.  In both
  cases the user would have to call a config function first to enable these
  notifications.
- inform clients about video norm changes: e.g. sampling rate may change
  (only relevant for raw data though), frame rate changes -> must be
  considered when evaluating time stamps to detect dropped frames;
  number of VBI lines may change, client may want to change service IDs.
  Probably only for clients which explicitly enable this; others could
  simply be starved.
- schedule channel change requests at background prio (level 0) at multiple
  sub-prio levels, e.g. immanent VPS/PDC, initial load, update, check;
  (see also discussion on mailing list)
- implement client-side channel change handling for background level,
  i.e. request scheduling from daemon, but don't do the change until the
  scheduler sends a grant.
- DVB channel changes (http://www.linuxtv.org/developer/dvb_api.xml)
- channel_switch in io-v4l2.c module is still missing (relevant API parts
  differ from v4l2k); also test io-v4l2.c::add_services against bttv8
- io-bktr.c not supported at all yet for new features

- possibly add a generic capture client config function to:
  + pass proxy background scheduler settings: prio, sub-prio etc.
  + report channel events: TV channel/freq. change, norm change
  + set video device path (v4l1 for channel changes & norm query)
  + sequence counter instead of time stamp in vbi_capture_buffer (v4l1 bttv)
- v4l2 API extensions:
  + channel change prio (implemented with #ifdef USE_V4L2K_CHNPRIO)
  + channel change event notification
  + CGUNIT to check if two nodes refer to the same piece of hardware?
    possibly extend struct v4l2_capability?
  + S_CTRL with flags to describe function group
  + STREAMOFF to stop cature when using read()?  Else the device has to be
    closed and re-opend to allow S_FMT, e.g. during add_services
  + EIO von DQBUF: timeout, buffer must be requeued - undocumented! what for?

-tom
